Title: Temporal Rust SDK

note __all__: [`Worker.run()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L229) 



...:

Wf Activations polling loop -> sdk-core: `poll_workflow_activation`

note sdk-core:
[`poll_workflow_activation()`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/mod.rs#L89)

[`next_workflow_activation()`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/workflow/mod.rs#L269)

note sdk-core: How are the state machines used?

[`worker::workflow` module](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/workflow/mod.rs#L3)

`worker::workflow::managed_run` module:

[`ManagedRun`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/workflow/managed_run.rs#L60) struct has a [`WorkflowManager`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/workflow/managed_run.rs#L1160) instance, which has a [`WorkflowMachines`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/workflow/machines/workflow_machines.rs#L72) instance.




note Wf Activations polling loop:
receive activation from server:  
[`Worker.workflow_activation_handler`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L296)

note:Activation is for a new workflow execution:  
[create `WorkflowFuture`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L406)
and
[send](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L302) it to stream processor for submission to Tokio.

note WorkflowFuture:
[`start_workflow()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L456)  

WorkflowFuture -> WorkflowFunction: create
note WorkflowFunction: [Create](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L65) a `WorkflowFunction` future by calling the user's async workflow function containing:
- a `WfContext` instance, with  
  - an `incoming_commands` send handle.

note WorkflowFuture:[Create](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L60) a `WorkflowFuture` containing:
- the `WorkflowFunction` future 
- `incoming_commands` receive handle
- `incoming_activations` receive handle
- `outgoing_completions` send handle

The `incoming_activations` send handle is [stored](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L229) in `Worker.workflows`.

The `outgoing_completions` receive handle is [stored](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L229) in a completions stream processor which calls sdk-core.

note Wf Activations polling loop:
[send](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L425) activation to Wf future incoming activations channel.

Wf Activations polling loop -> WorkflowFuture:


note WorkflowFuture: **Tokio** →  [`poll()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L440)

1. For every job in the activation:
[`handle_job(job)`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L468)  
(available [job variants](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/target/aarch64-apple-darwin/debug/build/temporal-sdk-core-protos-5d18df293f12871d/out/coresdk.workflow_activation.rs#L55))  

  job: [StartWorkflow](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L158) (`handle_job` is a no-op)  
  

2. [Advance](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L488) Workflow function 


WorkflowFuture -> WorkflowFunction: `poll()`
note WorkflowFunction:Workflow code reaches an activity call:
[`ctx.activity(activity_opts).await`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_context.rs#L204)

In `ctx.activity` we do two things:

1. Send a `ScheduleActivity` [command](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/target/aarch64-apple-darwin/debug/build/temporal-sdk-core-protos-5d18df293f12871d/out/coresdk.workflow_commands.rs#L23) to the `WorkflowFuture`, using our `incoming_commands` send handle. The command contains the [send end](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_context.rs#L439) of an `unblocker` channel.

WorkflowFunction -> WorkflowFuture: `ScheduleActivity` command

note WorkflowFuture:3. For every `incoming_command`, [add an entry](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L362) to `command_status` containing the `unblocker` for the command.


4. [send](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L507) the list of commands to `outgoing_completions`.  
  (available [command variants](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/target/aarch64-apple-darwin/debug/build/temporal-sdk-core-protos-5d18df293f12871d/out/coresdk.workflow_commands.rs#L23))

  This results in a `WorkflowActivationCompletion` proto being [sent](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L273) to the server by sdk-core
WorkflowFuture -> sdk-core: `complete_workflow_activation`

note WorkflowFunction:2. Return a `WFCommandFut`, to be awaited in the workflow code. The future contains the receive end of the `unblocker` channel.
...:
_:
note __all__: **TODO**: activity task is received, activity is called, resulting in next workflow activation containing a `ResolveActivity` job.

Activity task polling loop -> sdk-core: `poll_activity_task`

note Activity task polling loop:
[`activity_task_handler`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/sdk/src/lib.rs#L325)

[spawn future](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/sdk/src/lib.rs#L519)

note ActivityFuture: **Tokio** → poll  

[await activity fn](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/sdk/src/lib.rs#L520)  

[`complete_activity_task(result)`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/sdk/src/lib.rs#L547)

ActivityFuture -> sdk-core: 

note sdk-core:
[`complete_activity(status)`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/mod.rs#L127)  
[`WorkerActivityTasks.complete()`](https://github.com/temporalio/sdk-core/blob/6d04c20150d518f6b9ea5c18479d42d3a13d9085/core/src/worker/activities.rs#L300)


...:
_:

note Wf Activations polling loop:
receive activation from server:  
[`Worker.workflow_activation_handler`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L296)


note Wf Activations polling loop:
[send](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L425) activation to Wf future incoming activations channel.

Wf Activations polling loop -> WorkflowFuture:

note WorkflowFuture:**Tokio** →  [`poll()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L440)

1. For every job in the activation:
[`handle_job()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L468)  
(available [job variants](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/target/aarch64-apple-darwin/debug/build/temporal-sdk-core-protos-5d18df293f12871d/out/coresdk.workflow_activation.rs#L55))  


job: [`ResolveActivity(id, result)`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L164)

`handle_job()` calls [`unblock()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L116), and sends `UnblockEvent::Activity(result)` to the `unblocker` (which had been stored in `command_status`)

WorkflowFuture -> WorkflowFunction: `UnblockEvent::Activity(result)`

note WorkflowFuture:
2. [Advance](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_future.rs#L488) Workflow function 


WorkflowFuture -> WorkflowFunction: `poll()`

note WorkflowFunction:Recall that the workflow function is awaiting on `ctx.activity(act)`, and that this returns a `WFCommandFut`.

The [`WFCommandFut.poll()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/workflow_context.rs#L458) implementation handles the `UnblockEvent::Activity` by `take`-ing the `other_dat` (TODO: significance?) and calling [`Unblockable::unblock()`](https://github.com/temporalio/sdk-core/blob/492d687be48ce6ee81ef7d55c825d366c1e3c4c5/sdk/src/lib.rs#L616), the result of which is to return `Poll::Ready(act_result)`.

The workflow function thus advances beyond the activity call.


order: Wf Activations polling loop, WorkflowFuture, WorkflowFunction, Activity task polling loop, ActivityFuture, sdk-core
